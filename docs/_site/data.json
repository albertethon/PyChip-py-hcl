[{"layout":"default","title":"PyHCL","content":"# PyHCL\n[![Build Status](https://travis-ci.com/scutdig/py-hcl.svg?branch=master)](https://travis-ci.com/scutdig/py-hcl)\n[![codecov](https://codecov.io/gh/scutdig/py-hcl/branch/master/graph/badge.svg)](https://codecov.io/gh/scutdig/py-hcl)\n[![PyPI](https://img.shields.io/pypi/v/py-hcl.svg)](https://pypi.python.org/pypi)\n\nPyHCL is a hardware construct language like [Chisel](https://github.com/freechipsproject/chisel3) but more lightweight and more relaxed to use.\nAs a novel hardware construction framework embedded in Python, PyHCL supports several useful features include object-oriented, functional programming,\nand dynamically typed objects.\n\nThe goal of PyHCL is providing a complete design and verification tool flow for heterogeneous computing systems flexibly using the same design methodology.\n\nPyHCL is powered by [FIRRTL](https://github.com/freechipsproject/firrtl), an intermediate representation for digital circuit design.\n\nPyHCL-generated circuits can be compiled to the widely-used HDL Verilog.\n\nAttention: The back end of the compilation is highly experimental.\n\n\n## Simple Example\n\n### Writing A Full Adder\nPyHCL defines modules using only simple Python syntax that looks like this:\n```python\nfrom pyhcl import *\n\nclass FullAdder(Module):\n io = IO(\n a=Input(Bool),\n b=Input(Bool),\n cin=Input(Bool),\n sum=Output(Bool),\n cout=Output(Bool),\n )\n\n # Generate the sum\n io.sum @= io.a ^ io.b ^ io.cin\n\n # Generate the carry\n io.cout @= io.a & io.b | io.b & io.cin | io.a & io.cin\n```\n\n### Compiling To High FIRRTL\n\nCompiling module by calling `compile_to_highform`:\n```python\nEmitter.dump(Emitter.emit(FullAdder(), HighForm), \"FullAdder.fir\")\n```\n\nWill generate the following FIRRTL codes:\n```\ncircuit FullAdder :\n module FullAdder :\n input clock : Clock\n input reset : UInt<1>\n output io : {flip a : UInt<1>, flip b : UInt<1>, flip cin : UInt<1>, s : UInt<1>, cout : UInt<1>}\n \n node _T = xor(io.a, io.b)\n node _T_1 = xor(_T, io.cin)\n io.s <= _T_1\n node _T_2 = and(io.a, io.b)\n node _T_3 = and(io.a, io.cin)\n node _T_4 = or(_T_2, _T_3)\n node _T_5 = and(io.b, io.cin)\n node _T_6 = or(_T_4, _T_5)\n io.cout <= _T_6\n```\n\n### Compiling To Lowered FIRRTL\n\nCompiling module by calling `compile_to_lowform`:\n\n```python\nEmitter.dump(Emitter.emit(FullAdder(), LowForm), \"FullAdder.lo.fir\")\n```\n\nWill generate the following FIRRTL codes:\n\n```\ncircuit FullAdder :\n module FullAdder :\n input clock : Clock\n input reset : UInt<1>\n input io_a : UInt<1>\n input io_b : UInt<1>\n input io_cin : UInt<1>\n output io_s : UInt<1>\n output io_cout : UInt<1>\n \n node _T = xor(io_a, io_b)\n node _T_1 = xor(_T, io_cin)\n io_s <= _T_1\n node _T_2 = and(io_a, io_b)\n node _T_3 = and(io_a, io_cin)\n node _T_4 = or(_T_2, _T_3)\n node _T_5 = and(io_b, io_cin)\n node _T_6 = or(_T_4, _T_5)\n io_cout <= _T_6\n```\n\n### Compiling To Verilog\n\nCompiling module by calling `compile_to_verilog`:\n\n```shell\nEmitter.dump(Emitter.emit(FullAdder(), Verilog), \"FullAdder.v\")\n```\n\nThen `FullAdder.v` will be generated:\n```verilog\nmodule FullAdder(\n input\t\tclock,\n input\t\treset,\n input\t\tio_a,\n input\t\tio_b,\n input\t\tio_cin,\n output\t\tio_s,\n output\t\tio_cout\n);\n\n assign io_s = io_a ^ io_b ^ io_cin;\n assign io_cout = io_a & io_b | io_a & io_cin | io_b & io_cin;\n \nendmodule\n```\n\n\n## Features\n\n- Supports multiple data types: `UInt`, `SInt`, `Vector`, `Bundle`, `Clock`, `Memory`, and casual combination between them.\n- Supports object-oriented inheritance, can compose modules by writing fewer codes.\n- Supports a bunch of convenient operations, such as the addition of `UInt`s, `SInt`s, `Vector`s and `Bundle`s.\n- Supports the parameterization of variables, such as bit width, with the syntax facilities of the host language Python.\n\n\n## TODO\n\n- [ ] Supports more operations\n- [ ] PyHCL's verification facility\n","dir":"/AboutPyHCL/","name":"AboutPyHCL.md","path":"AboutPyHCL/AboutPyHCL.md","url":"/AboutPyHCL/AboutPyHCL.html"},{"layout":"default","title":"FAQ","content":"# FAQ\n## What is the overhead of PyHCL generated RTL compared to human written VHDL/Verilog?\nPyHCL is a hardware construct language like [Chisel](https://github.com/freechipsproject/chisel3) but more lightweight and more relaxed to use.\n\n## What if PyHCL becomes unsupported in the future?\nThis question has two sides:\n\n1. PyHCL generates VHDL/Verilog files, which means that PyHCL will be supported by all EDA tools for many decades.\n\n2. If there is a bug in PyHCL and there is no longer support to fix it, it’s not a deadly situation, because the PyHCL compiler is fully open source. For simple issues, you may be able to fix the issue yourself in few hours. Remember how much time it takes to EDA companies to fix issues or to add new features in their closed tools.\n\n## Does PyHCL keep comments in generated VHDL/verilog?\nNo, it doesn’t. Generated files should be considered as a netlist.\n## Could PyHCL scale up to big projects?\nPyHCL is powered by [FIRRTL](https://github.com/freechipsproject/firrtl), an intermediate representation for digital circuit design.\n\nPyHCL-generated circuits can be compiled to the widely-used HDL Verilog.\n\nAttention: The back end of the compilation is highly experimental.\n## How PyHCL came to be?\nThe dominant hardware design languages in industry are **Verilog** and **VHDL**, however this procedural language, which has been around for decades, can no longer meet the needs of today's increasingly large and complex integrated circuit chip development.\n\n**Chisel**, the pioneer of combining hardware design with high-level programming languages, has proposed the possibility of agile design for hardware by embedding hardware design into the high-level programming language Scala. Embedding a hardware design framework into an object-oriented programming language allows hardware design to enjoy the advantages of object-oriented language ontologies.\n\nHowever, since Chisel is based on Scala, this language has a small audience, is difficult to learn, and has a low community activity, making it difficult to get started and the learning time period is long, which is not conducive to its promotion. Therefore, our team uses the Python language to design and develop PyHCL to provide a more easy-to-use and concise hardware design framework.\n\n## Why develop a new language when there is VHDL/Verilog/SystemVerilog?\nThe goal of PyHCL is providing a complete design and verification tool flow for heterogeneous computing systems flexibly using the same design methodology.\n## How to use an unreleased version of PyHCL (but committed on git)?\n\n","dir":"/AboutPyHCL/","name":"FAQ.md","path":"AboutPyHCL/FAQ.md","url":"/AboutPyHCL/FAQ.html"},{"layout":"default","title":null,"content":"[![Build Status](https://travis-ci.com/scutdig/py-hcl.svg?branch=master)](https://travis-ci.com/scutdig/py-hcl)\n[![codecov](https://codecov.io/gh/scutdig/py-hcl/branch/master/graph/badge.svg)](https://codecov.io/gh/scutdig/py-hcl)\n[![PyPI](https://img.shields.io/pypi/v/py-hcl.svg)](https://pypi.python.org/pypi)\n# Support\n## Communication channels\nFor bug reporting and feature requests, do not hesitate to create github issues:\\\n<https://github.com/scutdig/PyChip-py-hcl/issues> \\\nFor questions, you can also use the forum StackOverflow with the tag PyHCL :\\\n<https://stackoverflow.com/> \n\n## Commercial support\nIf you are interested in a presentation, a workshop, or consulting, do not hesitate to contact us by email: \\\n<PyHCL@gmail.com> ","dir":"/AboutPyHCL/","name":"Support.md","path":"AboutPyHCL/Support.md","url":"/AboutPyHCL/Support.html"},{"layout":"default","title":"Users","content":"# Users\n## Companies\n## Repositories\n\n","dir":"/AboutPyHCL/","name":"Users.md","path":"AboutPyHCL/Users.md","url":"/AboutPyHCL/Users.html"},{"layout":"default","title":"Data Types","content":"# Data Types\n\n- Supports multiple data types: `UInt`, `SInt`, `Vector`, `Bundle`, `Clock`, `Memory`, and casual combination between them.\n- Supports object-oriented inheritance, can compose modules by writing fewer codes.\n- Supports a bunch of convenient operations, such as the addition of `UInt`s, `SInt`s, `Vector`s and `Bundle`s.\n- Supports the parameterization of variables, such as bit width, with the syntax facilities of the host language Python.\n\n\n## UInt/SInt\n* `U(N.w)`: length `N` unsigned integer that includes Bits operators and\n unsigned arithmetic (e.g. `+`, `-`, ...) and comparison operators (e.g.\n `<`, `<=`, ...)\n* `S(N.w)`: length `N` signed integer that includes Bits operators and\n signed arithmetic (e.g. `+`, `-`, ...) and comparison operators (e.g.\n `<`, `<=`, ...)\n\n## Bool\n* `Bool`: bool value，which is `U(1.w)`\n* `true, false`: boolean literals\n\n## Clock\n* `Clock`: bool value，which is `U(1.w)`\n* `true, false`: boolean literals\n\n\n## Bundle\n* `Input(T)`, `Output(T)` qualify type `T` to be an input, output, and\nrespectively.\n* `IO(T)` qualify type `T` to be an input, output, and\nrespectively.\n\n## Vec\n* `Vec(4, U.w(32))`: fixed length array of length `4` containing values of type\n `U.w(32)` with equality operator (`==`) defined\n\n## Registers\n\n* Retain state until updated:\n```python\nreg = Reg(U.w(32))\ncounter = RegInit(U.w(32)(0))\n```\n\n## Memories\n\n```python\nm = Mem(10, U.w(8))\nm[U(2)] @= io.i\nio.o @= m[U(2)]\n```\n\n## Circuits\n**Defining**: `Module`\n\n```python\nfrom pyhcl import *\nfrom pyhcl.simulator import Simulator\n\nclass FullAdder(Module):\n io = IO(\n a=Input(Bool),\n b=Input(Bool),\n cin=Input(Bool),\n sum=Output(Bool),\n cout=Output(Bool),\n )\n\n # Generate the sum\n a_xor_b = io.a ^ io.b\n io.sum @= a_xor_b ^ io.cin\n\n # Generate the carry\n a_and_b = io.a & io.b\n b_and_cin = io.b & io.cin\n a_and_cin = io.a & io.cin\n io.cout @= a_and_b | b_and_cin | a_and_cin\n```\n**Usage**: circuits are used by instancing them inside another definitions and\n their ports are accessed using dot notation\n\n```python\nFA = FullAdder()\n```\n\n**Metaprogramming**: abstract over parameters by generating a circuit definition inside a closure\n\n```python\ndef adder(n: int):\n class Adder(Module):\n io = IO(\n a=Input(U.w(n)),\n b=Input(U.w(n)),\n cin=Input(Bool),\n sum=Output(U.w(n)),\n cout=Output(Bool),\n )\n\n FAs = [FullAdder().io for _ in range(n)]\n carry = Wire(Vec(n + 1, Bool))\n sum = Wire(Vec(n, Bool))\n\n carry[0] @= io.cin\n\n for i in range(n):\n FAs[i].a @= io.a[i]\n FAs[i].b @= io.b[i]\n FAs[i].cin @= carry[i]\n carry[i + 1] @= FAs[i].cout\n sum[i] @= FAs[i].sum\n\n io.sum @= CatVecH2L(sum)\n io.cout @= carry[n]\n\n return Adder()\n```\n\n# Operators\n## Infix operators\nAll types support the following operators:\n- Equal `==`\n- Not Equal `!=`\n\nThe `Bool` type supports the following logical operators.\n- And `&`\n- Or `|`\n- Exclusive or `^`\n- Not `~`\n\n\nThe `UInt` and `SInt` types support all the logical operators\nas well as arithmetic and comparison operators.\n- Add `+`\n- Subtract/Negate `-`\n- Multiply `*`\n- Divide `/`\n- Less than `<`\n- Less than or equal `<=`\n- Greater than `>`\n- Greater than or equal `>=`\n\nNote that the the right shift operator when applied to an `SInt` becomes\nan arithmetic shift right operator (which replicates the sign bit as it shifts right).\n\n## Combinational\n\n```python\n# Mux(<选择信号>, <真输出>, <假输出>)\nio.z @= Mux(io.sel, io.b, io.a)\n```\n\n## Sequential\n\n```python\nclass Register(Module):\n io = IO(\n out=Output(U.w(32))\n )\n\n counter = RegInit(U.w(32)(0))\n counter @= counter + U(1)\n io.out @= counter\n```","dir":"/Datatypes/","name":"Data types.md","path":"Datatypes/Data types.md","url":"/Datatypes/Data%20types.html"},{"layout":"default","title":"Examples","content":"# Examples\n\n## Simple ones\n* Full_Adder\n \n```python\nclass FullAdder(Module):\n io = IO(\n a=Input(Bool),\n b=Input(Bool),\n cin=Input(Bool),\n sum=Output(Bool),\n cout=Output(Bool),\n )\n\n # Generate the sum\n a_xor_b = io.a ^ io.b\n io.sum @= a_xor_b ^ io.cin\n\n # Generate the carry\n a_and_b = io.a & io.b\n b_and_cin = io.b & io.cin\n a_and_cin = io.a & io.cin\n io.cout @= a_and_b | b_and_cin | a_and_cin\n```\n\n## Advanced ones\n* Filter\n \n```python\nfrom functools import reduce\nfrom typing import List\n\nfrom pyhcl import *\n\ndef myManyDynamicElementVecFir(length: int, consts: List):\n class MyManyDynamicElementVecFir(Module):\n io = IO(\n i=Input(U.w(8)),\n valid=Input(Bool),\n o=Output(U.w(8)),\n )\n\n taps = [io.i] + [RegInit(U.w(8)(0)) for _ in range(length)]\n for a, b in zip(taps, taps[1:]):\n with when(io.valid):\n b @= a\n\n m = map(lambda x: x[0] * x[1], zip(taps, consts))\n io.o @= reduce(lambda x, y: x + y, m)\n\n return MyManyDynamicElementVecFir()\n\n\ndef main():\n consts = []\n for i in range(4):\n consts.append(U(i))\n f = Emitter.dump(Emitter.emit(myManyDynamicElementVecFir(4, consts)), \"filter.fir\")\n Emitter.dumpVerilog(f)\n\n\nif __name__ == '__main__':\n main()\n```\n\n* Neurons\n \n```python\nfrom pyhcl import *\n\nW = 8 # 位宽\n\ndef matrixMul(x: int, y: int, z: int):\n \"\"\"\n x*y × y*z 矩阵乘法电路\n \"\"\"\n\n class MatrixMul(Module):\n io = IO(\n a=Input(Vec(x, Vec(y, U.w(W)))),\n b=Input(Vec(y, Vec(z, U.w(W)))),\n o=Output(Vec(x, Vec(z, U.w(W)))),\n )\n\n for i, a_row in enumerate(io.a):\n for j, b_col in enumerate(zip(*io.b)):\n io.o[i][j] @= Sum(a * b for a, b in zip(a_row, b_col))\n\n return MatrixMul()\n\n\ndef bias(n):\n return U.w(W)(n)\n\n\ndef weight(lst):\n return VecInit(U.w(W)(i) for i in lst)\n\n\ndef neurons(w, b):\n \"\"\"\n 参数：权重向量 w，偏移量 b\n 输出：神经网络神经元电路 *注：暂无通过非线性传递函数\n \"\"\"\n\n class Unit(Module):\n io = IO(\n i=Input(Vec(len(w), U.w(W))),\n o=Output(U.w(W))\n )\n m = matrixMul(1, len(w), 1).io\n m.a @= io.i\n\n m.b @= w\n io.o @= m.o[0][0] + b\n\n return Unit()\n\ndef main():\n # 得到权重向量为[3, 4, 5, 6, 7, 8, 9, 10]，偏移量为14的神经元电路\n n = neurons(weight([3, 4, 5, 6, 7, 8, 9, 10]), bias(14))\n f = Emitter.dump(Emitter.emit(n), \"neurons.fir\")\n Emitter.dumpVerilog(f)\n\nif __name__ == '__main__':\n main()\n```\n","dir":"/Examples/","name":"examples.md","path":"Examples/examples.md","url":"/Examples/examples.html"},{"layout":"default","title":"Getting Started","content":"# Getting Started\n\nPyHCL is a hardware construct language written in Python, a high-level, interpreted, general-purpose programming language. Python is dynamically-typed and garbage-collected . \n\n## Requirements / Things to download to get started\n\nBefore you download the PyHCL tools, you need to install:\n* Python 3.7 or above\n* FIRRTL environment\n\n### FIRRTL\nFirrtl is an intermediate representation (IR) for digital circuits designed as a platform for writing circuit-level transformations. In Chisel3 version, the framework tools are compiled in a chain from Scala to FIRRTL to Verilog. the introduction of FIRRTL makes the front and back end of the framework practically replaceable with other languages. the target language of PyHCL is FIRRTL and calls the FIRRTL compiler to generate Verilog code. So to use PyHCL you need to configure the FIRRTL environment.\nThe FIRRTL installation and configuration process is described in detail in the FIRRTL Github repo:\n\n<https://github.com/chipsalliance/firrtl#installation-instructions>\n\nYou need to follow the instructions above to install **verilator, yosys and sbt.** Then you need to compile and install FIRRTL.\n\nIf you successfully add firrtl to the environment variables, typing `firrtl --help` in the terminal will display the information about the firrtl command.\n\n## Other tools\n### GTKwave\nGTKwave is a free tool for viewing waveform files such as `.vcd` files generated by various simulation tools\n#### Install on Windows / MacOS\n<http://gtkwave.sourceforge.net/>\n#### Install on Linux\n```\napt-get install gtkwave\n```\n### CoCotb\nCocotb is a Python-based open source verification platform, similar in design to the UVM platform built using SystemVerilog. Cocotb is a relatively large and complex platform, so only simple simulation verification processes are described here, while other advanced uses can be found in the documentation if the reader is interested.\n\n> Cocotb Site:<https://cocotb.org/> \\\n> Cocotb Github repo:<https://github.com/cocotb/cocotb> \\\n> Cocotb Documents:<https://cocotb.readthedocs.io/en/latest/index.html>\n\n#### Installation\n<https://cocotb.readthedocs.io/en/latest/quickstart.html#quickstart-guide>\n#### Instructions\nTo use Cocotb for simulation testing, you need to provide: \n* dut's Verilog file\n* a test harness written in Python\n* a Makefile file\n\nThe following is an example of how to use Cocotb to test a full adder. If you need other more advanced methods, you can refer to the official documentation.\n\n\n## How to start programming with PyHCL\n### The SBT way\n### The IDE way, with PyCharm IDE and its Scala plugin\n## A very simple PyHCL example\n### Generated code\n\n\n\n```shell\ngit clone git@github.com:scutdig/PyChip-py-hcl.git\n```\n\n## firrtl\nhttps://github.com/chipsalliance/firrtl\n\n## Motivation\n\nWith the rapid development of heterogeneous systems, the traditional hardware development methods require innovations. On the one hand, agile hardware development becomes more critical in developing system-on-chips (SoCs) due to its short development cycles and fast prototyping fea-tures. On the other hand, traditional hardware description languages (HDLs) lack productivity and efﬁciency to develop heterogeneous systems. Moreover, there is a significant methodology gap between the current main-stream hardware design and verification tools. In this paper, we introduce PyChip, a novel Python-based full-stack hardware development framework. PyChip includes PyHCL for circuit construction and PyUVM for design verification. To achieve agile hardware development, PyHCL provides a clean and precise interface for developers to rapidly design hardware cir-cuits. PyUVM provides three verification approaches for various verifica-tion levels and strategies, including the capabilities for universal verifica-tion methodology (UVM). Besides, we built a multi-level verification envi-ronment based on the UVM feature provided by PyUVM, which supports the gray-box verification strategy and remains outstanding simulation per-formance and high reusability. The implementation and simulation results show that PyChip has excellent hardware development efficiency and per-formance. The PyHCL implementations have a 69% code density reduction compare to the hand-written Verilog code on average. The two combina-tional verification approaches provided by the multi-level verification en-vironment have 63% and 40% improvement of simulation performance compared to the single approaches, respectively.\n\n## Python Guide\nhttps://www.python.org/about/gettingstarted/\n\n\n\n\n\n\n\n\n\n\n","dir":"/GettingStarted/","name":"GettingStarted.md","path":"GettingStarted/GettingStarted.md","url":"/GettingStarted/GettingStarted.html"},{"layout":"default","title":null,"content":"","dir":"/GettingStarted/","name":"Motivation.md","path":"GettingStarted/Motivation.md","url":"/GettingStarted/Motivation.html"},{"layout":"default","title":"Other Features","content":"# Other Features\n\n## Pysv\n\n```python\nimport random\n\nfrom pyhcl import *\nfrom pysv import sv, DataType, Reference\nfrom pyhcl.simulator import Simlite, DpiConfig\nimport random\n\nclass Add(BlackBox):\n io = IO(\n in1=Input(U.w(32)),\n out=Output(U.w(32))\n )\n\n\n@sv(a=DataType.UInt, return_type=Reference(x=DataType.UInt))\ndef fn(a):\n return a + 10000\n\n\naddpysvmodule(Add, fn)\n\nclass Rand(BlackBox):\n io = IO(\n in1=Input(U.w(32)),\n in2=Input(U.w(32)),\n out=Output(U.w(32))\n )\n\n\n@sv(a=DataType.UInt, b=DataType.UInt, return_type=Reference(x=DataType.UInt))\ndef fn2(a, b):\n return random.randint(a, b)\n\n\naddpysvmodule(Rand, fn2)\ncompile_and_binding_all()\n\n\nclass Top(Module):\n io = IO(\n a=Input(U.w(32)),\n b=Input(U.w(32)),\n c=Output(U.w(32))\n )\n\n wire = Wire(U.w(32))\n\n r = Rand()\n add = Add()\n r.io.in1 @= io.a\n r.io.in2 @= io.b\n wire @= r.io.out\n add.io.in1 @= wire\n io.c @= add.io.out\n\n\n\nif __name__ == '__main__':\n cfg = DpiConfig()\n # Emitter.dumpVerilog(Emitter.dump(Emitter.emit(Top()), \"Top.fir\"))\n\n s = Simlite(Top(), harness_code=None, dpiconfig=cfg)\n s.step([20, 20])\n s.step([15, 100])\n s.step([1000, 2000])\n s.step([999, 2010])\n\n```\n\n## 仿真和混合仿真\n\n## assert \n\n```python\nfrom pyhcl import *\n\n\nclass AND(RawModule):\n io = IO(\n a=Input(U.w(1)),\n b=Input(U.w(1)),\n s=Output(U.w(1)),\n )\n\n myclock = Input(Clock())\n myreset = Input(Bool)\n io.s @= io.a ^ io.b\n _ = doAssert(myclock, io.a, io.s, \"IF io.a is HIGH then io.s is HIGH\")\n\n\nif __name__ == '__main__':\n fa = AND()\n Emitter.dump(Emitter.emit(fa), \"and.fir\")\n```\n\n## 双向连接 \n* `@`\n \n## 内联FIRRTL\n## Features\nAs a novel hardware construction framework embedded in Python, PyHCL supports several useful features.\n- Supports multiple data types: `UInt`, `SInt`, `Vector`, `Bundle`, `Clock`, `Memory`, and casual combination between them.\n- Supports object-oriented inheritance, can compose modules by writing fewer codes.\n- Supports functional programming\n- Supports a bunch of convenient operations, such as the addition of `UInt`s, `SInt`s, `Vector`s and `Bundle`s.\n- Supports the parameterization of variables, such as bit width, with the syntax facilities of the host language Python.\n\n\n## TODO\n\n- [ ] Supports more operations\n- [ ] PyHCL's verification facility\n","dir":"/OtherFeatures/","name":"OtherFeatures.md","path":"OtherFeatures/OtherFeatures.md","url":"/OtherFeatures/OtherFeatures.html"},{"layout":"default","title":"Semantic","content":"# Semantic\n\n## Assignments\n* `@=` and `@=` \n```python\n# io.sum @= a_xor_b ^ io.cin\nio.sum @= a_xor_b ^ io.cin\n```\n\n## Control Flow\n* `with when()` `with elsewhen()` and `with otherwise`\n\n* `Mux`\n \n```python\nio.o @= Mux(io.i, a, b)\n```\n\n## Rules\n","dir":"/Semantic/","name":"Semantic.md","path":"Semantic/Semantic.md","url":"/Semantic/Semantic.html"},{"layout":"default","title":"Sequential Logic","content":"# Sequential Logic\n\n## Registers\n* Retain state until updated:\n \n```python\nreg = Reg(U.w(32))\ncounter = RegInit(U.w(32)(0))\n```\n\n## RAM/ROM/Mem\n\n```python\nclass MemDemo(Module):\n io = IO(\n i=Input(U.w(8)),\n o=Output(U.w(8)),\n )\n\n m = Mem(10, U.w(8))\n m[U(2)] @= io.i\n io.o @= m[U(2)]\n```","dir":"/SequentialLogic/","name":"SequentialLogic.md","path":"SequentialLogic/SequentialLogic.md","url":"/SequentialLogic/SequentialLogic.html"},{"layout":"default","title":"Structuring","content":"# Structuring\n\n## module and hierarchy\n* All circle must extends `Module` \n \n```python\nclass FullAdder(Module):\n io = IO(\n a=Input(Bool),\n b=Input(Bool),\n cin=Input(Bool),\n sum=Output(Bool),\n cout=Output(Bool),\n )\n\n # Generate the sum\n a_xor_b = io.a ^ io.b\n io.sum @= a_xor_b ^ io.cin\n\n # Generate the carry\n a_and_b = io.a & io.b\n b_and_cin = io.b & io.cin\n a_and_cin = io.a & io.cin\n io.cout @= a_and_b | b_and_cin | a_and_cin\n```\n\n## Clock domains\n\n```python\nclass Counter(RawModule):\n io = IO(\n i=Input(Bool),\n o=Output(U.w(32)),\n )\n\n myclk = Clock()\n myrst = Reset()\n\n with clockdomin(myclk, myrst):\n r0 = RegInit(U.w(32)(0))\n\n with when(io.i):\n r0 @= r0 + U.w(32)(1)\n\n io.o @= r0\n```\n\n## Instamtiate Verilog IP\n\n```python\nclass BBox(BlackBox):\n io = IO(\n in1=Input(U.w(64)),\n in2=Input(U.w(64)),\n out=Output(U.w(64)),\n )\n\n\nclass M(Module):\n io = IO(\n i = Input(U.w(64)),\n o = Output(U.w(64)),\n )\n\n bbox = BBox()\n bbox.io.in1 @= io.i\n bbox.io.in2 @= io.i\n io.o @= bbox.io.out\n\nif __name__ == '__main__':\n Emitter.dumpVerilog(Emitter.dump(Emitter.emit(M()), \"bbox.fir\"))\n```\n\n## Parametrization\n\n```python\ndef myManyDynamicElementVecFir(length: int, consts: List):\n class MyManyDynamicElementVecFir(Module):\n io = IO(\n i=Input(U.w(8)),\n valid=Input(Bool),\n o=Output(U.w(8)),\n )\n\n taps = [io.i] + [RegInit(U.w(8)(0)) for _ in range(length)]\n for a, b in zip(taps, taps[1:]):\n with when(io.valid):\n b @= a\n\n m = map(lambda x: x[0] * x[1], zip(taps, consts))\n io.o @= reduce(lambda x, y: x + y, m)\n\n return MyManyDynamicElementVecFir()\n```","dir":"/Structuring/","name":"Structuring.md","path":"Structuring/Structuring.md","url":"/Structuring/Structuring.html"},{"permalink":"//","layout":"default","title":"Welcome to the PyHCL Documentation","content":"# Welcome to the PyHCL Documentation\n\n## site purpose and structure\n\nThis site presents the PyHCL language and how to use it on concrete examples.\n\n## What is PyHCL\n\nPyHCL is a hardware construct language like [Chisel](https://github.com/freechipsproject/chisel3) but more lightweight and more relaxed to use.\nAs a novel hardware construction framework embedded in Python, PyHCL supports several useful features include object-oriented, functional programming,\nand dynamically typed objects.\n\nThe goal of PyHCL is providing a complete design and verification tool flow for heterogeneous computing systems flexibly using the same design methodology.\n\nPyHCL is powered by [FIRRTL](https://github.com/freechipsproject/firrtl), an intermediate representation for digital circuit design. With the FIRRTL \ncompiler framework, PyHCL-generated circuits can be compiled to the widely-used HDL Verilog. \n\n\n## Similar Projects\n\n* [autofpga](https://github.com/ZipCPU/autofpga) - C++, A utility for Composing FPGA designs from Peripherals\n* [BinPy](https://github.com/BinPy/BinPy) - Python, An electronic simulation library\n* [blarney](https://github.com/blarney-lang/blarney) - Haskell, HCL\n* [bsc](https://github.com/B-Lang-org/bsc) - Haskell, C++, BSV - Bluespec Compiler\n* [chisel](https://chisel.eecs.berkeley.edu/) - 2012-?, Scala, HCL\n* [Chips-2.0](https://github.com/dawsonjon/Chips-2.0) - , , FPGA Design Suite based on C to Verilog design flow\n* [circt](https://github.com/llvm/circt) - 2020-?, C++/LLVM, compiler infrastructure\n* [circuitgraph](https://github.com/circuitgraph/circuitgraph) - Tools for working with circuits as graphs in python\n* [concat](https://github.com/conal/concat) - 2016-?, Haskell, Haskell to hardware\n* [DUH](https://github.com/sifive/duh) - JS, simple convertor between verilog/scala/ipxact\n* [DFiant](https://github.com/DFiantHDL/DFiant) 2019-?, Scala, dataflow based HDL\n* [edalize](https://github.com/olofk/edalize) - 2018-?, Python, abstraction layer for eda tools\n* [garnet](https://github.com/StanfordAHA/garnet) -2018-?, Python, Coarse-Grained Reconfigurable Architecture generator based on magma\n* [hammer](https://github.com/ucb-bar/hammer) - 2017-?, Python, Highly Agile Masks Made Effortlessly from RTL\n* [heterocl](https://github.com/cornell-zhang/heterocl) - 2017-?, C++, A Multi-Paradigm Programming Infrastructure for Software-Defined Reconfigurable Computing\n* [hoodlum](https://github.com/tcr/hoodlum) - 2016-?, Rust, HCL\n* [ILAng](https://github.com/Bo-Yuan-Huang/ILAng) - modeling and verification platform for SoCs where Instruction-Level Abstraction (ILA) is used as the formal model for hardware components.\n* :skull: [jhdl](https://github.com/larsjoost/jhdl) - ?-2017, C++ Verilog/VHDL -> systemC, prototype\n* [Kactus2](http://funbase.cs.tut.fi) - IP-core packager\n* [kratos](https://github.com/Kuree/kratos) - C++/Python, hardware generator/simulator\n* [lgraph](https://github.com/masc-ucsc/lgraph) - C, generic graph library\n* [llhd](https://github.com/fabianschuiki/llhd) - Rust, HCL\n* [livehd](https://github.com/masc-ucsc/livehd) - mainly C++, An infrastructure designed for Live Hardware Development.\n* [Lucid HDL in Alchitry-Labs](https://github.com/alchitry/Alchitry-Labs) - Custom language and IDE inspired by Verilog\n* [magma](https://github.com/phanrahan/magma/) - 2017-?, Python, HCL\n* [migen](https://github.com/m-labs/migen) - 2013-?, Python, HCL\n* [mockturtle](https://github.com/lsils/mockturtle) - logic network library\n* [moore](https://github.com/fabianschuiki/moore) - Rust, HDL -> model compiler\n* [MyHDL](https://github.com/myhdl/myhdl) - 2004-?, Python, Process based HDL\n* [nmigen](https://github.com/m-labs/nmigen) -, Python, A refreshed Python toolbox for building complex digital hardware\n* [OpenTimer](https://github.com/OpenTimer/OpenTimer) - , C++, A High-Performance Timing Analysis Tool for VLSI Systems\n* [percy](https://github.com/whaaswijk/percy) - Collection of different synthesizers and exact synthesis methods for use in applications such as circuit resynthesis and design exploration.\n* [PyChip-py-hcl](https://github.com/scutdig/PyChip-py-hcl) - , Python, Chisel3 like HCL\n* [pygears](https://github.com/bogdanvuk/pygears) - , Python, function style HDL generator\n* [PyMTL3](https://github.com/cornell-brg/pymtl3) 2018-?\n* [PyMTL](https://github.com/cornell-brg/pymtl) - 2014-?, Python, Process based HDL\n* [PipelineC](https://github.com/JulianKemmerer/PipelineC) - 2018-?, Python, C++ HLS-like automatic pipelining as a language construct/compiler\n* [PyRTL](https://github.com/UCSBarchlab/PyRTL) - 2015-?, Python, HCL\n* [Pyverilog](https://github.com/PyHDI/Pyverilog) - 2013-? Python-based Hardware Design Processing Toolkit for Verilog HDL\n* [rogue](https://github.com/slaclab/rogue) , C++/Python - Hardware Abstraction & Data Acquisition System\n* [sail](https://github.com/rems-project/sail) 2018-?, (OCaml, Standard ML, Isabelle) - architecture definition language\n* [spatial](https://github.com/stanford-ppl/spatial) - Scala, an Argon DSL like, high level abstraction\n* [SpinalHDL](https://github.com/SpinalHDL/SpinalHDL) - 2015-?, Scala, HCL\n* [Silice](https://github.com/sylefeb/Silice) - ?, C++, Custom HDL\n* :skull: [SyDpy](https://github.com/bogdanvuk/sydpy) - ?-2016, Python, HCL and verif. framework operating on TML/RTL level\n* [systemrdl-compiler](https://github.com/SystemRDL/systemrdl-compiler) - Python,c++, register description language compiler\n* [UHDM](https://github.com/alainmarcel/UHDM) - C++ SystemVerilog -> C++ model\n* :skull: [Verilog.jl](https://github.com/interplanetary-robot/Verilog.jl) - 2017-2017, Julia, simple Julia to Verilog transpiler\n* [veriloggen](https://github.com/PyHDI/veriloggen) - 2015-?, Python, Verilog centric HCL with HLS like features\n* :skull: [wyre](https://github.com/nickmqb/wyre) - 2020-2020, Mupad, Minimalistic HDL\n* [phi](https://github.com/donn/Phi) - 2019-?, custom language, llvm based compiler of custom hdl\n* [prga](https://github.com/PrincetonUniversity/prga) - 2019-?. Python, prototyping platform with integrated yosys\n\n\n\n\n\nSee the sidebar for various pages.\n<!-- 关于模板说明，docs为整个文档的根目录，其下文件夹为一级目录, 每一级目录的readme.md为该级目录的索引 -->\n\n<!-- pkill -f jekyll 杀\n bundle exec jekyll serve 开\n-->\n\n* [About PyHCL](/AboutPyHCL/)\n* [Data types](/Datatypes/)\n* [Examples](/Examples/)\n* [Getting Stated](/GettingStarted/)\n\n<!-- \n仿照spinalhdl来写\n.关于：说明\n.开始：安装\n.数据类型：Bool，bits，这些\n.语法：赋值，选择，\n.等级：module，，，\n.时序逻辑：多时钟域\n.仿真\n.例子：滤波器设计。。。\n.提升：\n -->\n\n","dir":"/","name":"readme.md","path":"readme.md","url":"/"},{"sort":1,"permalink":"/AboutPyHCL/","layout":"default","title":"About Pyhcl","content":"<h1 id=\"about-pyhcl\">About Pyhcl</h1>\n\n<ul>\n <li><a href=\"/AboutPyHCL/AboutPyHCL.html\">PyHCL</a></li>\n <li><a href=\"/AboutPyHCL/FAQ.html\">FAQ</a></li>\n <li><a href=\"/AboutPyHCL/Support.html\">Support.md</a></li>\n <li><a href=\"/AboutPyHCL/Users.html\">Users</a></li>\n</ul>\n","dir":"/AboutPyHCL/","name":"readme.md","path":"AboutPyHCL/readme.md","url":"/AboutPyHCL/"},{"sort":2,"permalink":"/GettingStarted/","layout":"default","title":"Getting Started","content":"<h1 id=\"getting-started\">Getting Started</h1>\n\n<ul>\n <li><a href=\"/GettingStarted/GettingStarted.html\">Getting Started</a></li>\n <li><a href=\"/GettingStarted/Motivation.html\">Motivation.md</a></li>\n</ul>\n","dir":"/GettingStarted/","name":"readme.md","path":"GettingStarted/readme.md","url":"/GettingStarted/"},{"sort":3,"permalink":"/Datatypes/","layout":"default","title":"Data types","content":"<h1 id=\"data-types\">Data types</h1>\n\n<ul>\n <li><a href=\"/Datatypes/Data%20types.html\">Data Types</a></li>\n</ul>\n","dir":"/Datatypes/","name":"readme.md","path":"Datatypes/readme.md","url":"/Datatypes/"},{"sort":4,"permalink":"/Structuring/","layout":"default","title":"Structuring","content":"<h1 id=\"structuring\">Structuring</h1>\n\n<ul>\n <li><a href=\"/Structuring/Structuring.html\">Structuring</a></li>\n</ul>\n","dir":"/Structuring/","name":"readme.md","path":"Structuring/readme.md","url":"/Structuring/"},{"sort":5,"permalink":"/Semantic/","layout":"default","title":"Semantic","content":"<h1 id=\"semantic\">Semantic</h1>\n\n<ul>\n <li><a href=\"/Semantic/Semantic.html\">Semantic</a></li>\n</ul>\n","dir":"/Semantic/","name":"readme.md","path":"Semantic/readme.md","url":"/Semantic/"},{"sort":6,"permalink":"/SequentialLogic/","layout":"default","title":"Sequential Logic","content":"<h1 id=\"sequential-logic\">Sequential Logic</h1>\n\n<ul>\n <li><a href=\"/SequentialLogic/SequentialLogic.html\">Sequential Logic</a></li>\n</ul>\n","dir":"/SequentialLogic/","name":"readme.md","path":"SequentialLogic/readme.md","url":"/SequentialLogic/"},{"sort":7,"permalink":"/DesignErrors/","layout":"default","title":"About Pyhcl","content":"<h1 id=\"about-pyhcl\">About Pyhcl</h1>\n\n","dir":"/DesignErrors/","name":"readme.md","path":"DesignErrors/readme.md","url":"/DesignErrors/"},{"sort":8,"permalink":"/OtherFeatures/","layout":"default","title":"Other Features","content":"<h1 id=\"other-features\">Other Features</h1>\n\n<ul>\n <li><a href=\"/OtherFeatures/OtherFeatures.html\">Other Features</a></li>\n</ul>\n","dir":"/OtherFeatures/","name":"readme.md","path":"OtherFeatures/readme.md","url":"/OtherFeatures/"},{"sort":9,"permalink":"/Libraries/","layout":"default","title":"About Pyhcl","content":"<h1 id=\"about-pyhcl\">About Pyhcl</h1>\n\n","dir":"/Libraries/","name":"readme.md","path":"Libraries/readme.md","url":"/Libraries/"},{"sort":11,"permalink":"/FormalVerification/","layout":"default","title":"Formal Verification","content":"<h1 id=\"formal-verification\">Formal Verification</h1>\n\n","dir":"/FormalVerification/","name":"readme.md","path":"FormalVerification/readme.md","url":"/FormalVerification/"},{"sort":12,"permalink":"/Examples/","layout":"default","title":"Examples","content":"<h1 id=\"examples\">Examples</h1>\n\n<ul>\n <li><a href=\"/Examples/examples.html\">Examples</a></li>\n</ul>\n","dir":"/Examples/","name":"readme.md","path":"Examples/readme.md","url":"/Examples/"},{"sort":13,"permalink":"/Legacy/","layout":"default","title":"About Pyhcl","content":"<h1 id=\"about-pyhcl\">About Pyhcl</h1>\n\n","dir":"/Legacy/","name":"readme.md","path":"Legacy/readme.md","url":"/Legacy/"},{"sort":14,"permalink":"/DevelopersArea/","layout":"default","title":"About Pyhcl","content":"<h1 id=\"about-pyhcl\">About Pyhcl</h1>\n\n","dir":"/DevelopersArea/","name":"readme.md","path":"DevelopersArea/readme.md","url":"/DevelopersArea/"}]